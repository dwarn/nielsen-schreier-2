import category_theory.action
       group_theory.semidirect_product
       free

open category_theory is_free_group semidirect_product

universe u
instance action_category_is_free_groupoid {G A : Type u} [group G] [mul_action G A] [is_free_group G] :
  is_free_groupoid (action_category G A) :=
let ac := (action_category.obj_equiv G A).symm in
let gens := Œª x y, { a : gp_gens G // (gp_emb a) ‚Ä¢ ac x = ac y } in
let emb := Œª x y (e : gens x y), (show x ‚ü∂ y, from ‚ü®gp_emb e.val, e.property‚ü©) in
{ gpd_gens := gens,
  gpd_emb := emb,
  gpd_lift := begin
    introsI X _ f,
    set Y := (A ‚Üí X) ‚ãä[my_mul_aut G A X] G,
    set f' : gp_gens G ‚Üí Y := Œª e, ‚ü®Œª b,
      @f ‚ü®(), _‚ü© ‚ü®(), b‚ü© ‚ü®e, smul_inv_smul _ _‚ü©, gp_emb e‚ü©,
    rcases gp_lift f' with ‚ü®p, hp, up‚ü©,
    have sane : ‚àÄ g : G, (p g).right = g,
    { set p' := right_hom.comp p,
      apply is_free_group_ext p',
      intro e, change (p _).right = _, rw ‚Üêhp },
    let F : action_category G A ‚•§ single_obj X,
    { refine {
        obj := Œª _, (),
        map := Œª a b q, (p q.val).left (ac b),
        map_id' := _, map_comp' := _ },
      { intro a, change (p 1).left _ = 1,
        rw p.map_one, refl },
      { intros a b c f g,
        change (p (_ * _)).left _ = _ * _, rw p.map_mul, 
        change _ * _ = _ * _, congr,
        change (p f.val).left _ = _, congr,
        rw [inv_smul_eq_iff, sane],
        exact g.property.symm } },
    refine ‚ü®F, _, _‚ü©,
    { intros a b e,
      change f e = (p _).left _,
      rw ‚Üêhp,
      change f _ = f _,
      rcases a with ‚ü®‚ü®‚ü©, a‚ü©,
      rcases b with ‚ü®‚ü®‚ü©, b‚ü©,
      rcases e with ‚ü®e, h‚ü©,
      rw ‚Üêeq_inv_smul_iff at h,
      cases h, refl },
    { intros F' hF',
      have F'_congr : ‚àÄ (a b c d : action_category G A) (f g : G)
        (h1 : (f ‚Ä¢ a.snd : A) = b.snd) (h2 : (g ‚Ä¢ c.snd : A) = d.snd),
          a = c ‚Üí b = d ‚Üí f = g ‚Üí (F'.map ‚ü®f, h1‚ü© : X) = (F'.map ‚ü®g, h2‚ü© : X),
      { rintros _ _ _ _ _ _ _ _ ‚ü®‚ü© ‚ü®‚ü© ‚ü®‚ü©, refl },
      have ssmul : ‚àÄ (g : G) (b : A), (g ‚Ä¢ (ac.symm $ g‚Åª¬π ‚Ä¢ b).snd : A) = (ac.symm b).snd,
      { apply smul_inv_smul },
      set p' : G ‚Üí* Y := { 
        to_fun := Œª g, ‚ü®Œª b, F'.map ‚ü®g, ssmul g b‚ü©, g‚ü©,
        map_one' := begin
          congr, funext, change F'.map _ = 1,
          have : (1 : X) = F'.map (ùüô (ac.symm b)),
          { rw F'.map_id, refl },
          rw this, apply F'_congr,
          { simp only [one_inv, one_smul] },
          all_goals { refl },
        end,
        map_mul' := begin
          intros g h, congr, funext,
          have : F'.map ‚ü®_, ssmul (g * h) b‚ü© ==
            F'.map ‚ü®h, ssmul h (g‚Åª¬π ‚Ä¢ b)‚ü© ‚â´ F'.map ‚ü®g, ssmul g b‚ü©,
          { apply heq_of_eq,
            rw ‚ÜêF'.map_comp,
            apply F'_congr,
            { rw [mul_inv_rev, mul_smul] },
            all_goals { refl } },
          rw heq_iff_eq at this,
          exact this
        end },
      have : p' = p,
      { apply up,
        intro e,
        apply semidirect_product.ext,
        { funext, apply hF' },
        { refl } },
      apply functor.hext,
      { intro, apply unit.ext },
      rintros ‚ü®‚ü®‚ü©, a : A‚ü© ‚ü®‚ü®‚ü©, b : A‚ü© ‚ü®g, h : g ‚Ä¢ a = b‚ü©,
      change _ == (p _).left _,
      rw ‚Üêthis,
      change F'.map _ == F'.map _,
      apply heq_of_eq,
      apply F'_congr,
      { congr, 
        rw eq_inv_smul_iff,
        exact h },
      all_goals { refl } }
  end,
  ind := begin
    intros,
    let Q : G ‚Üí Prop := Œª g, ‚àÄ (x y : action_category G A) (z : x ‚ü∂ y),
        g = subtype.val z ‚Üí P z,
    have claim : ‚àÄ g, Q g,
    { apply is_free_group_induction Q,
      { rintros e x y ‚ü®_, h‚ü© ‚ü®‚ü©,
        change P (emb x y ‚ü®e, h‚ü©),
        apply base },
      { rintros ‚ü®‚ü®‚ü©, x: A‚ü© ‚ü®‚ü®‚ü©, y‚ü© ‚ü®_, h‚ü© ‚ü®‚ü©,
        have : x = y,
        { change (1 : G) ‚Ä¢ x = y at h, simpa using h },
        cases this,
        apply id },
      { rintros g h gq hq x y ‚ü®_, prop‚ü© ‚ü®‚ü©,
        let gh : x ‚ü∂ y := ‚ü®g * h, prop‚ü©,
        change P gh,
        let mi : action_category G A := ac.symm (h ‚Ä¢ x.snd),
        let hh : x ‚ü∂ mi := ‚ü®h, rfl‚ü©,
        let gg : mi ‚ü∂ y := ‚ü®g, _‚ü©,
        have : gh = (hh ‚â´ gg),
        { ext, refl },
        rw this,
        apply comp,
        { apply hq, refl },
        { apply gq, refl },
        change _ ‚Ä¢ _ ‚Ä¢ _ = _,
        rw smul_smul,
        exact prop, },
      { rintros g gq x y ‚ü®_, prop‚ü© ‚ü®‚ü©,
        let ii : y ‚ü∂ x := ‚ü®g, _‚ü©,
        swap,
        { change _ ‚Ä¢ _ = _, symmetry, rw ‚Üêinv_smul_eq_iff, assumption },
        change P (inv ii),
        apply comp_1,
        apply gq,
        refl } },
    apply claim f.val, refl
  end }
