import category_theory.category.Cat category_theory.category.Groupoid to_mathlib

-- this file contains the construction of displayed categories
-- see https://arxiv.org/pdf/1705.04296.pdf

open category_theory

structure disp_cat (C) [category C] :=
(obj  : C ‚Üí Sort*) 
(mor  : Œ† {a b : C}, (a ‚ü∂ b) ‚Üí obj a ‚Üí obj b ‚Üí Sort*)
(id   : Œ† {a : C} (x : obj a), mor (ùüô a) x x)
(comp : Œ† {a b c : C} {f : a ‚ü∂ b} {g : b ‚ü∂ c}
        {x : obj a} {y : obj b} {z : obj c},
          mor f x y ‚Üí mor g y z ‚Üí mor (f ‚â´ g) x z)
(id_comp : ‚àÄ {a b : C} {f : a ‚ü∂ b} {x : obj a} {y : obj b} (F : mor f x y),
              comp (id x) F == F . obviously )
(comp_id : ‚àÄ {a b : C} {f : a ‚ü∂ b} {x : obj a} {y : obj b} (F : mor f x y),
              comp F (id y) == F . obviously )
(assoc : ‚àÄ {a b c d : C} {f : a ‚ü∂ b} {g : b ‚ü∂ c} {h : c ‚ü∂ d}
            {x : obj a} {y : obj b} {z : obj c} {w : obj d}
              (F : mor f x y) (G : mor g y z) (H : mor h z w),
                comp (comp F G) H == comp F (comp G H) . obviously )

structure disp_groupoid (G) [groupoid G] extends disp_cat G :=
(inv : Œ† {a b : G} {x : obj a} {y : obj b} {f : a ‚ü∂ b}, mor f x y ‚Üí mor (inv f) y x)
(inv_comp : ‚àÄ {a b : G} {f : a ‚ü∂ b} {x : obj a} {y : obj b} (F : mor f x y),
  comp (inv F) F == id y . obviously)
(comp_inv : ‚àÄ {a b : G} {f : a ‚ü∂ b} {x : obj a} {y : obj b} (F : mor f x y),
  comp F (inv F) == id x . obviously)

-- a displayed category is also a genuine category
def disp_cat.total {C} [category C] (D : disp_cat C) : Cat :=
{ Œ± := Œ£ c : C, D.obj c,
  str := { hom      := Œª x y, Œ£ f : x.fst ‚ü∂ y.fst, D.mor f x.snd y.snd,
           id       := Œª x, ‚ü®ùüô x.fst, D.id x.snd‚ü©,
           comp     := Œª x y z F G, ‚ü®F.fst ‚â´ G.fst, D.comp F.snd G.snd‚ü©,
           id_comp' := by { intros, apply sigma.ext, apply category.id_comp, apply D.id_comp },
           comp_id' := by { intros, apply sigma.ext, apply category.comp_id', apply D.comp_id },
           assoc'   := by { intros, apply sigma.ext, apply category.assoc, apply D.assoc } } }

def disp_groupoid.total {G} [groupoid G] (D : disp_groupoid G) : Groupoid :=
{ Œ± := D.to_disp_cat.total.Œ±,
  str := { inv       := Œª x y F, ‚ü®inv F.fst, D.inv F.snd‚ü©,
           inv_comp' := by { intros, apply sigma.ext, apply groupoid.inv_comp, apply D.inv_comp },
           comp_inv' := by { intros, apply sigma.ext, apply groupoid.comp_inv, apply D.comp_inv }, } }

@[ext]
structure disp_functor {C D} [category C] [category D]
  (Œ± : C ‚•§ D) (C' : disp_cat C) (D' : disp_cat D) :=
(obj : Œ† {a : C}, C'.obj a ‚Üí D'.obj (Œ±.obj a))
(map : Œ† {a b : C} {f : a ‚ü∂ b} {x : C'.obj a} {y : C'.obj b}, C'.mor f x y ‚Üí D'.mor (Œ±.map f) (obj x) (obj y))
(map_id : Œ† {a : C} (x : C'.obj a), map (C'.id x) == D'.id (obj x) . obviously)
(map_comp : Œ† {a b c : C} {f : a ‚ü∂ b} {g : b ‚ü∂ c} {x : C'.obj a} {y : C'.obj b} {z : C'.obj c}
              (F : C'.mor f x y) (G : C'.mor g y z),
                map (C'.comp F G) == D'.comp (map F) (map G))

def disp_cat.œÄ {C} [category C] (D : disp_cat C) :
  functorial (Œª x : D.total, x.fst) :=
{ map := Œª _ _, sigma.fst }

def terminal_disp (C) [category C] : disp_cat C :=
{ obj  := Œª _, unit, -- would be nice to use `true` instead for judgemental proof irrelevance
  mor  := Œª _ _ _ _ _, unit,
  id   := Œª _ _, (),
  comp := Œª _ _ _ _ _ _ _ _ _ _, () }

def terminal_functorial (C) [category C] : @functorial C _ _ (terminal_disp C).total.str (Œª c, ‚ü®c, ()‚ü©) :=
{ map := Œª a b f, ‚ü®f, ()‚ü© }

-- given a section of the projection functor which is strict on objects,
-- make it strict also on morphisms
lemma strictify_map {C} [category C] {D : disp_cat C}
  {ob : Œ† c : C, D.obj c} {f : @functorial C _ _ D.total.str (Œª c, ‚ü®c, ob c‚ü©)}
  (h : functorial_comp f D.œÄ = functorial_id C) :
    ‚àÉ (ma : Œ† {c d : C} (p : c ‚ü∂ d), D.mor p (ob c) (ob d)),
      f.map = (Œª c d p, ‚ü®p, ma p‚ü©) :=
begin
  refine ‚ü®_, _‚ü©,
  { intros c d p,
    convert (f.map p).snd,
    change p = (functorial_comp f $ disp_cat.œÄ D).map p,
    rw h, refl },
  funext,
  apply sigma.ext,
  { change (functorial_comp f $ disp_cat.œÄ D).map x_2 = x_2,
    rw h, refl },
  symmetry, simp, --??
end