import algebra.category.Group
       category_theory.category.Groupoid
       category_theory.single_obj
       category_theory.functor
       category_theory.elements
       quiver
       to_mathlib

open category_theory

universes u v

-- The property of being the free group on a subset
def is_free_group (G : Group) (A : set G) : Prop :=
âˆ€ (X : Group) (f : A â†’ X),
âˆƒ! (F : G âŸ¶ X), f = F âˆ˜ coe

-- The property of being the free groupoid on a subquiver
def is_free_groupoid (G : Groupoid.{v u}) (A : subquiver â™¯G.Î±) : Prop :=
âˆ€ (X : Groupoid.{v u}) (x : G.Î± â†’ X.Î±) (f : Â¡A â†’[x] â™¯X.Î±),
âˆƒ! (F : functorial x), f = (â™®F âŠš sub_hom A) -- todo figure out why we need brackets

-- a group is free iff it is a free groupoid
lemma free_group_iff_free_groupoid (G : Group) (A : set G) :
  is_free_group G A â†” is_free_groupoid (Groupoid.of $ single_obj G.Î±) (Î» _ _, A) :=
begin
  split,
  { intros hfree X,
    change âˆ€ x : punit â†’ X.Î±, _,
    rw function.surjective.forall (const_unit_surjective X.Î±),
    intros x f,
    specialize hfree (Group.of $ End x) (Î» a, @f (single_obj.star G) (single_obj.star G) a),
    refine ((functor_equiv x).symm.exists_unique_congr _).mp hfree,
    intro g,
    rw [out_of_unit, out_of_unit],
    refl, },
  { intros hfree X f,
    let x := single_obj.star X.Î±,
    specialize hfree (Groupoid.of $ single_obj X.Î±) (Î» _, x)
      (Î» _ _ a, f a),
    refine ((functor_equiv x).symm.exists_unique_congr _).mpr hfree,
    intro g,
    rw [out_of_unit, out_of_unit],
    refl, },
end

section covering_map

variables {G : Groupoid} (A : subquiver â™¯G.Î±) (F : G.Î± â¥¤ Type*)

-- pull back a subquiver to the total category
def pullback_subquiver : subquiver â™¯F.elements :=
Î» a b, { f | f.val âˆˆ A a.1 b.1 }

section temp

variables {X : Groupoid} (x : F.elements â†’ X.Î±)
include X x

structure Y := (of : G.Î±)

variables {F x}
def homsets : Y F x â†’ Y F x â†’ Type* :=
Î» a b, Î£ f : a.of âŸ¶ b.of,
  Î  (s : F.obj a.of) (t : F.obj b.of) (h : t = F.map f s),
    x âŸ¨a.of, sâŸ© âŸ¶ x âŸ¨b.of, tâŸ©

lemma homset_eq (a b : Y F x) (f g : homsets a b) :
 f = g â†” âˆƒ (fg : f.fst = g.fst), âˆ€ s, f.snd s _ rfl = g.snd s _ (by rw [fg]) :=
begin
  split,
  { rintro âŸ¨âŸ©, use rfl, intros, refl },
  { cases f, cases g, rintros âŸ¨âŸ¨âŸ©, hhâŸ©, refine sigma.eq rfl _, funext, cases x_3, apply hh },
end

lemma snd_congr {a b : Y F x} {f : homsets a b} {s s' : F.obj a.of} {t t' : F.obj b.of}
  {h : t = F.map f.fst s} (hs : s = s') (ht : t = t') :
    f.snd s t h = eq_to_hom (by rw hs) â‰« f.snd s' t' (by rwa [hs, ht] at h) â‰« eq_to_hom (by rw ht) :=
by { cases hs, cases ht, simp }

-- we construct a groupoid with the same objects as G,
-- where a morphism a âŸ¶ b is such a morphism f in G together
-- with a choice of morphisms in X for all morphisms above f in F.elements
instance : groupoid (Y F x) :=
{ hom := homsets,
  id := Î» a, âŸ¨ğŸ™ a.of, Î» s t h, eq_to_hom (by simp [h])âŸ©,
  comp := Î» a b c G H, âŸ¨G.fst â‰« H.fst, Î» s t h, G.snd s _ rfl â‰« H.snd _ t (by simp [h])âŸ©,
  id_comp' := begin 
    intros a b f, 
    rw homset_eq,
    refine âŸ¨by simp, _âŸ©,
    intro s,
    change _ â‰« f.snd (F.map (ğŸ™ a.of) s) _ _ = _,
    have : F.map (ğŸ™ a.of) s = s,
    { simp },
    rw snd_congr this rfl,
    simp,
  end,
  comp_id' := begin
    intros a b f,
    rw homset_eq,
    refine âŸ¨by simp, _âŸ©, 
    intro s,
    change _ â‰« eq_to_hom _ = f.snd s (F.map (f.fst â‰« ğŸ™ b.of) s) _,
    have : F.map (f.fst â‰« ğŸ™ b.of) s = F.map f.fst s,
    { simp },
    rw snd_congr rfl this,
    simp,
  end,
  assoc' := begin
    intros,
    rw homset_eq,
    refine âŸ¨by simp, _âŸ©,
    intro s,
    change (_ â‰« _) â‰« _ = _ â‰« _ â‰« _,

  end,
  inv := sorry,
  inv_comp' := sorry,
  comp_inv' := sorry }

end temp

-- Given an action of a free groupoid, its category of elements
-- is freely generated by the pullback subquiver.
-- This lemma corresponds to the fact that any covering map of a graph is
-- also a graph. In the HoTT formalization of Nielsen-Schreier, it corresponds
-- to the fact that `coequalizers are stable under pullback'
lemma elements_is_free_groupoid (h : is_free_groupoid G A) :
  is_free_groupoid (Groupoid.of $ F.elements) (pullback_subquiver A F) :=
begin

end

end covering_map