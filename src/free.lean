import algebra.category.Group
       category_theory.category.Groupoid
       category_theory.single_obj
       category_theory.functor
       category_theory.elements
       quiver
       to_mathlib

open category_theory

universes u v

-- The property of being the free group on a subset
def is_free_group (G : Group) (A : set G) : Prop :=
∀ (X : Group) (f : A → X),
∃! (F : G ⟶ X), f = F ∘ coe

-- The property of being the free groupoid on a subquiver
def is_free_groupoid (G : Groupoid.{v u}) (A : subquiver ♯G.α) : Prop :=
∀ (X : Groupoid.{v u}) (x : G.α → X.α) (f : ¡A →[x] ♯X.α),
∃! (F : functorial x), f = (♮F ⊚ sub_hom A) -- todo figure out why we need brackets

-- a group is free iff it is a free groupoid
lemma free_group_iff_free_groupoid (G : Group) (A : set G) :
  is_free_group G A ↔ is_free_groupoid (Groupoid.of $ single_obj G.α) (λ _ _, A) :=
begin
  split,
  { intros hfree X,
    change ∀ x : punit → X.α, _,
    rw function.surjective.forall (const_unit_surjective X.α),
    intros x f,
    specialize hfree (Group.of $ End x) (λ a, @f (single_obj.star G) (single_obj.star G) a),
    refine ((functor_equiv x).symm.exists_unique_congr _).mp hfree,
    intro g,
    rw [out_of_unit, out_of_unit],
    refl, },
  { intros hfree X f,
    let x := single_obj.star X.α,
    specialize hfree (Groupoid.of $ single_obj X.α) (λ _, x)
      (λ _ _ a, f a),
    refine ((functor_equiv x).symm.exists_unique_congr _).mpr hfree,
    intro g,
    rw [out_of_unit, out_of_unit],
    refl, },
end

section covering_map

variables {G : Groupoid} (A : subquiver ♯G.α) (F : G.α ⥤ Type*)

-- pull back a subquiver to the total category
def pullback_subquiver : subquiver ♯F.elements :=
λ a b, { f | f.val ∈ A a.1 b.1 }

section temp

variables {X : Groupoid} (x : F.elements → X.α)
include X x

structure Y := (of : G.α)

variables {F x}
def homsets : Y F x → Y F x → Type* :=
λ a b, Σ f : a.of ⟶ b.of,
  Π (s : F.obj a.of) (t : F.obj b.of) (h : t = F.map f s),
    x ⟨a.of, s⟩ ⟶ x ⟨b.of, t⟩

lemma homset_eq (a b : Y F x) (f g : homsets a b) :
 f = g ↔ ∃ (fg : f.fst = g.fst), ∀ s, f.snd s _ rfl = g.snd s _ (by rw [fg]) :=
begin
  split,
  { rintro ⟨⟩, use rfl, intros, refl },
  { cases f, cases g, rintros ⟨⟨⟩, hh⟩, refine sigma.eq rfl _, funext, cases x_3, apply hh },
end

lemma snd_congr {a b : Y F x} {f : homsets a b} {s s' : F.obj a.of} {t t' : F.obj b.of}
  {h : t = F.map f.fst s} (hs : s = s') (ht : t = t') :
    f.snd s t h = eq_to_hom (by rw hs) ≫ f.snd s' t' (by rwa [hs, ht] at h) ≫ eq_to_hom (by rw ht) :=
by { cases hs, cases ht, simp }

-- we construct a groupoid with the same objects as G,
-- where a morphism a ⟶ b is such a morphism f in G together
-- with a choice of morphisms in X for all morphisms above f in F.elements
instance : groupoid (Y F x) :=
{ hom := homsets,
  id := λ a, ⟨𝟙 a.of, λ s t h, eq_to_hom (by simp [h])⟩,
  comp := λ a b c G H, ⟨G.fst ≫ H.fst, λ s t h, G.snd s _ rfl ≫ H.snd _ t (by simp [h])⟩,
  id_comp' := begin 
    intros a b f, 
    rw homset_eq,
    refine ⟨by simp, _⟩,
    intro s,
    change _ ≫ f.snd (F.map (𝟙 a.of) s) _ _ = _,
    have : F.map (𝟙 a.of) s = s,
    { simp },
    rw snd_congr this rfl,
    simp,
  end,
  comp_id' := begin
    intros a b f,
    rw homset_eq,
    refine ⟨by simp, _⟩, 
    intro s,
    change _ ≫ eq_to_hom _ = f.snd s (F.map (f.fst ≫ 𝟙 b.of) s) _,
    have : F.map (f.fst ≫ 𝟙 b.of) s = F.map f.fst s,
    { simp },
    rw snd_congr rfl this,
    simp,
  end,
  assoc' := begin
    intros,
    rw homset_eq,
    refine ⟨by simp, _⟩,
    intro s,
    change (_ ≫ _) ≫ _ = _ ≫ _ ≫ _,

  end,
  inv := sorry,
  inv_comp' := sorry,
  comp_inv' := sorry }

end temp

-- Given an action of a free groupoid, its category of elements
-- is freely generated by the pullback subquiver.
-- This lemma corresponds to the fact that any covering map of a graph is
-- also a graph. In the HoTT formalization of Nielsen-Schreier, it corresponds
-- to the fact that `coequalizers are stable under pullback'
lemma elements_is_free_groupoid (h : is_free_groupoid G A) :
  is_free_groupoid (Groupoid.of $ F.elements) (pullback_subquiver A F) :=
begin

end

end covering_map