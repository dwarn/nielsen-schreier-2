import free quiver misc

open_locale classical

open category_theory is_free_groupoid

universe u
variables {G : Type u} [groupoid.{u u} G] [is_free_groupoid G] [inhabited G]
  (T : subquiver (symmy gpd_gens : quiver G))

def path_to_hom : Î  {a : G}, (Â¡T).path (default G) a â†’ ((default G) âŸ¶ a)
| _ quiver.path.nil := ğŸ™ _
| _ (quiver.path.cons p âŸ¨sum.inl f, _âŸ©) := (path_to_hom p) â‰« (gpd_emb f)
| _ (quiver.path.cons p âŸ¨sum.inr f, _âŸ©) := (path_to_hom p) â‰« inv (gpd_emb f)

variable [is_arbor Â¡T]

def favourite_hom (a : G) : (default G âŸ¶ a) :=
path_to_hom T (default _)

def to_End {a b : G} (p : a âŸ¶ b) : End (default G) :=
favourite_hom T a â‰« p â‰« inv (favourite_hom T b)

lemma favourite_hom_root : favourite_hom T (default G) = ğŸ™ _ :=
begin
  change path_to_hom T _ = _,
  have : default ((Â¡T).path (default G) _) = quiver.path.nil,
  { apply unique.default_eq },
  rw this, refl,
end

lemma End_to_End (p : End (default G)) : to_End T p = p :=
by {rw [to_End, favourite_hom_root], simp }

lemma to_End_eq_id {a b : G} {e : gpd_gens a b} :
  (sum.inl e) âˆˆ T a b âˆ¨ (sum.inr e) âˆˆ T b a 
    â†’ to_End T (gpd_emb e) = ğŸ™ _ := 
begin
  rw [to_End, â†category.assoc, is_iso.comp_inv_eq, category.id_comp,
    favourite_hom, favourite_hom],
  rintro (h | h),
  { set to_b : (Â¡T).path (default G) b :=
      quiver.path.cons (default _) âŸ¨sum.inl e, hâŸ©,
    have : default _ = to_b := unique.default_eq _,
    rw this, refl },
  { set to_a : (Â¡T).path (default G) a :=
      quiver.path.cons (default _) âŸ¨sum.inr e, hâŸ©,
    have : default _ = to_a := unique.default_eq _,
    simp only [this, path_to_hom, is_iso.inv_hom_id, category.comp_id, category.assoc] },
end

def functor_of_mul_hom {X} [group X] (f : (End (default G)) â†’* X) :
  G â¥¤ single_obj X :=
{ obj := Î» _, (),
  map := Î» a b p, f (to_End T p),
  map_id' := begin intro a, convert f.map_one, simp [to_End] end,
  map_comp' := begin
    intros a b c p q,
    change _ = _ * _,
    rw â†f.map_mul,
    apply congr_arg,
    simp only [to_End, is_iso.inv_hom_id_assoc, End.mul_def, category.assoc]
  end }

-- an automorphism group in a free groupoid is freely generated by the
-- complement of a spanning tree.
-- conceptually, this is because 
-- `(End r âŸ¶ X) â‰ƒ (G â¥¤ single_obj X / natural isos taking value 1 on r)`
--             `â‰ƒ functors G â¥¤ single_obj X mapping spanning tree to 1 `
--             `â‰ƒ set functions on complement of spanning tree`.
def contract : is_free_group (End (default G)) :=
{ gp_gens := set.compl (tree_symmy T),
  gp_emb := Î» tp, to_End T (gpd_emb tp.val.edge),
  gp_lift := begin
    introsI X _ f,
    let f' : valu gpd_gens X := Î» a b e,
      if h : (sum.inl e âˆˆ T a b âˆ¨ sum.inr e âˆˆ T b a) then 1
      else f âŸ¨âŸ¨a, b, eâŸ©, hâŸ©,
    rcases gpd_lift @f' with âŸ¨F, hF, uFâŸ©,
    have F_path_to_hom : âˆ€ {a : G} {p : (Â¡T).path (default G) a},
      F.map (path_to_hom T p) = 1,
    { intros a p,
      induction p with b c p e ih,
      { apply F.map_id },
      rcases e with âŸ¨e, eTâŸ©,
      rcases e with e | e,
      { change F.map (_ â‰« _ ) = _,
        rw [functor.map_comp, ih, â†hF],
        change _ â‰« dite _ _ _ = _,
        rw dif_pos (or.inl eT),
        apply mul_one },
      { change F.map (_ â‰« inv _) = _,
        rw [F.map_comp, ih, F.map_inv],
        suffices : F.map (gpd_emb e) = 1,
        { rw [is_iso.comp_inv_eq, this], symmetry, apply mul_one },
        rw â†hF,
        change dite _ _ _ = _,
        rw dif_pos (or.inr eT) } },
    let ghom : (End (default G)) â†’* X := functor.map_End (default G) F,
    have sane : functor_of_mul_hom T ghom = F,
    { apply functor.hext, 
      { intro, apply unit.ext }, 
      intros, apply heq_of_eq,
      change F.map ((path_to_hom T _) â‰« _ â‰« inv (path_to_hom T _)) =
        (show single_obj.star X âŸ¶ (), from F.map f_1),
      rw [F.map_comp, F.map_comp, F.map_inv, â†category.assoc,
          is_iso.comp_inv_eq, F_path_to_hom, F_path_to_hom],
      change _ * _ = _ * _,
      rw [mul_one, one_mul],
    },
    refine âŸ¨ghom, _, _âŸ©,
    { intro tp,
      change f _ = (functor_of_mul_hom T ghom).map _,
      rw [sane, â†hF], change f _ = dite _ _ _,
      rw dif_neg,
      { apply congr_arg, ext; refl },
      exact tp.property },
    { intros z zh,
      have : functor_of_mul_hom T z = F,
      { apply uF, intros a b e,
        change dite _ _ _ = z (to_End T _),
        split_ifs,
        { rw to_End_eq_id T h, exact z.map_one.symm },
        { apply zh } },
      ext,
      have : (functor_of_mul_hom T z).map x = (functor_of_mul_hom T ghom).map x,
      { rw [this, sane] },
      convert this; rw End_to_End },
  end }
