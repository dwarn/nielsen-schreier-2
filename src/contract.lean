import free quiver

open_locale classical

open category_theory

lemma functorial.map_inv {C D} [groupoid C] [groupoid D] {ob : C â†’ D}
  (f : functorial ob) (a b : C) (p : a âŸ¶ b) :
    f.map (inv p) = inv (f.map p) :=
begin
  suffices : f.map (inv p) = inv (f.map p) â‰« (ğŸ™ _),
  { simp only [this, category.comp_id]},
  rw [is_iso.eq_inv_comp, â†f.map_comp'],
  simp only [f.map_id', is_iso.hom_inv_id],
end

def functorial.to_functor {C D} [category C] [category D] {ob : C â†’ D}
  (f : functorial ob) : C â¥¤ D :=
{ obj := ob,
  map := f.map,
  map_id' := Î» a, f.map_id' _,
  map_comp' := Î» _ _ _ _ _, f.map_comp' _ _ }

-- we should be able to generalise universe level with a universe-polymorphic single-obj
universe u
variables {G : Type} [groupoid.{u 0} G] {A : subquiver â™¯G}
  (T : subquiver ((Â¡A) âŠ• (Â¡A)áµ’áµ–)) [inhabited G]

local notation `r` := default G

def path_to_hom : Î  {a : G}, (Â¡T).path r a â†’ (r âŸ¶ a)
| _ quiver.path.nil := ğŸ™ r
| _ (quiver.path.cons p âŸ¨sum.inl f, _âŸ©) := (path_to_hom p) â‰« f.val
| _ (quiver.path.cons p âŸ¨sum.inr f, _âŸ©) := (path_to_hom p) â‰« inv f.val

variable [(Â¡T).is_tree]

def favourite_hom (a : G) : (r âŸ¶ a) :=
path_to_hom T (quiver.is_tree.favourite _)

def to_End {a b : G} (p : a âŸ¶ b) : End r :=
favourite_hom T a â‰« p â‰« inv (favourite_hom T b)

def generators : set (End r) :=
{ x | âˆƒ a b (e : A a b), 
  x = to_End T e.val
  âˆ§ Â¬ ( (sum.inl e) âˆˆ T a b âˆ¨ (sum.inr e) âˆˆ T b a) }

lemma favourite_hom_root : favourite_hom T r = ğŸ™ r :=
begin
  change path_to_hom T _ = _,
  have : quiver.is_tree.favourite r = quiver.path.nil,
  { symmetry, apply quiver.is_tree.is_favourite },
  rw this, refl,
end

lemma End_to_End (p : End r) : to_End T p = p :=
by {rw [to_End, favourite_hom_root], simp }

lemma to_End_eq_id {a b : G} {e : (Â¡A) a b} :
  (sum.inl e) âˆˆ T a b âˆ¨ (sum.inr e) âˆˆ T b a 
    â†’ to_End T e.val = ğŸ™ r := 
begin
  rw [to_End, â†category.assoc, is_iso.comp_inv_eq, category.id_comp,
    favourite_hom, favourite_hom],
  rintro (h | h),
  { set to_b : (Â¡T).path r b :=
      quiver.path.cons (quiver.is_tree.favourite _) âŸ¨sum.inl e, hâŸ©,
    have : to_b = _ := quiver.is_tree.is_favourite _,
    rw â†this, refl },
  { set to_a : (Â¡T).path r a :=
      quiver.path.cons (quiver.is_tree.favourite _) âŸ¨sum.inr e, hâŸ©,
    have : to_a = _ := quiver.is_tree.is_favourite _,
    rw [â†this, path_to_hom],
    simp only [is_iso.inv_hom_id, category.comp_id, category.assoc], },
end

def functor_of_mul_hom {X : Group} (f : (End r) â†’* X) :
  @functorial G _ (single_obj X) _ (Î» _, ()) :=
{ map := Î» a b p, f (to_End T p),
  map_id' := begin intro a, convert f.map_one, simp [to_End] end,
  map_comp' := begin
    intros a b c p q,
    change _ = _ * _,
    rw â†f.map_mul,
    apply congr_arg,
    simp only [to_End, is_iso.inv_hom_id_assoc, End.mul_def, category.assoc]
  end }

-- an automorphism group in a free groupoid is freely generated by the
-- complement of a spanning tree.
-- conceptually, this is because 
-- `(End r âŸ¶ X) â‰ƒ (G â¥¤ single_obj X / natural isos taking value 1 on r)`
--             `â‰ƒ functors G â¥¤ single_obj X mapping spanning tree to 1 `
--             `â‰ƒ set functions on complement of spanning tree`.
theorem contract (hfree : is_free_groupoid G A) : is_free_group (End r) (generators T)
 :=
assume X f,
let ob : G â†’ (single_obj X) := Î» _, single_obj.star _ in
let f' : (Â¡A) â†’[ob] â™¯(single_obj X) := 
  Î» a b e, if   h : _ then ğŸ™ _
           else f âŸ¨_, a, b, e, rfl, hâŸ© in
let âŸ¨F, hF, uFâŸ© := hfree (Groupoid.of $ single_obj X) ob f' in
have F_path_to_hom : Î  {a : G} {p : (Â¡T).path r a}, F.map (path_to_hom T p) = ğŸ™ _ :=
begin
  intros a p,
  induction p with b c p e ih,
  { apply F.map_id' },
  rcases e with âŸ¨e, eTâŸ©,
  rcases e with âŸ¨e, eAâŸ© | âŸ¨e, eAâŸ©,
  { change F.map (_ â‰« _) = _,
    rw [F.map_comp', ih],
    change (ğŸ™ _) â‰« (â™®F âŠš sub_hom A) _ = _,
    rw â†hF,
    change (ğŸ™ _) â‰« dite _ _ _ = _,
    rw dif_pos (or.inl eT),
    simp only [category.comp_id]},
  { change F.map (_ â‰« inv _) = _,
    rw [F.map_comp', ih, F.map_inv],
    suffices : F.map e = ğŸ™ _,
    { simp only [this, is_iso.comp_inv_eq, category.comp_id]},
    change (â™®F âŠš sub_hom A) âŸ¨e, eAâŸ© = _,
    rw â†hF,
    change dite _ _ _ = _,
    rw dif_pos (or.inr eT) }
end,
let ghom : (End r) â†’* X := functor.map_End r F.to_functor in
have sane : functor_of_mul_hom T ghom = F := begin
  ext,
  change F.map (path_to_hom T _ â‰« _ â‰« inv (path_to_hom _ _)) = F.map _,
  rw [F.map_comp', F.map_comp', functorial.map_inv, F_path_to_hom, F_path_to_hom],
  simp only [is_iso.comp_inv_eq, category.id_comp, category.comp_id],
end,
âŸ¨ghom,
begin
  funext, rcases x with âŸ¨_, a, b, p, âŸ¨âŸ©, nnâŸ©,
  change f _ = (functor_of_mul_hom T ghom).map _,
  rw sane, change f _ = (â™®F âŠš sub_hom A) _,
  rw â†hF, change f _ = dite _ _ _,
  rw dif_neg nn, refl,
end,
begin
  intros z zh, ext,
  have : functor_of_mul_hom T z = F,
  { apply uF, ext,
    change dite _ _ _ = z (to_End T x_3.val),
    by_cases (sum.inl x_3) âˆˆ T _ _ âˆ¨ (sum.inr x_3) âˆˆ T _ _,
    { rw [dif_pos h, to_End_eq_id T h],
      change _ = z 1, rw z.map_one, refl },
    { rw [dif_neg h, zh], refl } },
  have : (functor_of_mul_hom T z).map x = (functor_of_mul_hom T ghom).map x,
  { rw [this, sane] },
  convert this; rw End_to_End
endâŸ©