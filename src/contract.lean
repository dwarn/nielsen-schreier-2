import free
       quiver
       misc

open_locale classical

open category_theory is_free_groupoid

universe v
variables {G : Type} [groupoid.{v 0} G] [is_free_groupoid G] [inhabited G]
  (T : subquiver (symmy gpd_gens : quiver G))

def path_to_hom : Î  {a : G}, (Â¡T).path (default G) a â†’ ((default G) âŸ¶ a)
| _ quiver.path.nil := ğŸ™ _
| _ (quiver.path.cons p âŸ¨sum.inl f, _âŸ©) := (path_to_hom p) â‰« (gpd_emb f)
| _ (quiver.path.cons p âŸ¨sum.inr f, _âŸ©) := (path_to_hom p) â‰« inv (gpd_emb f)

variable [is_tree Â¡T]

def favourite_hom (a : G) : (default G âŸ¶ a) :=
path_to_hom T (default _)

def to_End {a b : G} (p : a âŸ¶ b) : End (default G) :=
favourite_hom T a â‰« p â‰« inv (favourite_hom T b)

lemma favourite_hom_root : favourite_hom T (default G) = ğŸ™ _ :=
begin
  change path_to_hom T _ = _,
  have : default ((Â¡T).path (default G) _) = quiver.path.nil,
  { apply unique.default_eq },
  rw this, refl,
end

lemma End_to_End (p : End (default G)) : to_End T p = p :=
by {rw [to_End, favourite_hom_root], simp }

lemma to_End_eq_id {a b : G} {e : gpd_gens a b} :
  (sum.inl e) âˆˆ T a b âˆ¨ (sum.inr e) âˆˆ T b a 
    â†’ to_End T (gpd_emb e) = ğŸ™ _ := 
begin
  rw [to_End, â†category.assoc, is_iso.comp_inv_eq, category.id_comp,
    favourite_hom, favourite_hom],
  rintro (h | h),
  { set to_b : (Â¡T).path (default G) b :=
      quiver.path.cons (default _) âŸ¨sum.inl e, hâŸ©,
    have : default _ = to_b := unique.default_eq _,
    rw this, refl },
  { set to_a : (Â¡T).path (default G) a :=
      quiver.path.cons (default _) âŸ¨sum.inr e, hâŸ©,
    have : default _ = to_a := unique.default_eq _,
    simp only [this, path_to_hom, is_iso.inv_hom_id, category.comp_id, category.assoc] },
end

def functorial_of_mul_hom {X} [group X] (f : (End (default G)) â†’* X) :
  functorial (Î» (g : G), single_obj.star X) :=
{ map := Î» a b p, f (to_End T p),
  map_id' := begin intro a, convert f.map_one, simp [to_End] end,
  map_comp' := begin
    intros a b c p q,
    change _ = _ * _,
    rw â†f.map_mul,
    apply congr_arg,
    simp only [to_End, is_iso.inv_hom_id_assoc, End.mul_def, category.assoc]
  end }

-- an automorphism group in a free groupoid is freely generated by the
-- complement of a spanning tree.
-- conceptually, this is because 
-- `(End r âŸ¶ X) â‰ƒ (G â¥¤ single_obj X / natural isos taking value 1 on r)`
--             `â‰ƒ functors G â¥¤ single_obj X mapping spanning tree to 1 `
--             `â‰ƒ set functions on complement of spanning tree`.
def contract : is_free_group (End (default G)) :=
{ gp_gens := set.compl (tree_symmy T),
  gp_emb := Î» tp, to_End T (gpd_emb tp.val.edge),
  gp_lift := begin
    introsI X _ f,
    let f' : quiver_hom gpd_gens â™¯(single_obj X) := 
    { obj := Î» _, (),
      edge := Î» a b e, if h : (sum.inl e âˆˆ T a b âˆ¨ sum.inr e âˆˆ T b a) then ğŸ™ _
                       else f âŸ¨âŸ¨a, b, eâŸ©, hâŸ© },
    rcases gpd_lift f' with âŸ¨F, hF, uFâŸ©,
    resetI,
    have map_eq_map' : âˆ€ {a b : G} (p : a âŸ¶ b), map f'.obj p = F.map' p := Î» _ _ _, rfl,
    have F_path_to_hom : âˆ€ {a : G} {p : (Â¡T).path (default G) a},
      map f'.obj (path_to_hom T p) = ğŸ™ _,
    { intros a p,
      induction p with b c p e ih,
      { apply functorial.map_id },
      rcases e with âŸ¨e, eTâŸ©,
      rcases e with e | e,
      { change map f'.obj (_ â‰« _ ) = _,
        rw [functorial.map_comp, ih, map_eq_map', â†hF],
        change _ â‰« dite _ _ _ = _,
        rw dif_pos (or.inl eT),
        apply category.comp_id },
      { change map f'.obj (_ â‰« inv _) = _,
        rw [functorial.map_comp, ih, functorial.map_inv],
        suffices : map f'.obj (gpd_emb e) = ğŸ™ _,
        { simp only [this, is_iso.comp_inv_eq, category.comp_id] },
        rw [map_eq_map', â†hF],
        change dite _ _ _ = _,
        rw dif_pos (or.inr eT) } },
    let ghom : (End (default G)) â†’* X := functor.map_End (default G) (functor.of f'.obj),
    have sane : functorial_of_mul_hom T ghom = F,
    { rw functorial_ext, intros,
      change map f'.obj ((path_to_hom T _) â‰« _ â‰« inv (path_to_hom T _)) = _,
      rw [functorial.map_comp, functorial.map_comp, functorial.map_inv, 
          F_path_to_hom, F_path_to_hom, map_eq_map'],
      simp only [is_iso.comp_inv_eq, category.id_comp, category.comp_id] },
    refine âŸ¨ghom, _, _âŸ©,
    { intro tp,
      change f _ = (functorial_of_mul_hom T ghom).map' _,
      rw [sane, â†hF], change f _ = dite _ _ _,
      rw dif_neg,
      { apply congr_arg, ext; refl },
      exact tp.property },
    { intros z zh,
      have : functorial_of_mul_hom T z = F,
      { apply uF, intros a b e,
        change dite _ _ _ = z (to_End T _),
        by_cases sum.inl e âˆˆ T a b âˆ¨ sum.inr e âˆˆ T b a,
        { rw [dif_pos h, to_End_eq_id T h], exact z.map_one.symm },
        { rw [dif_neg h, zh] } },
      ext,
      have : (functorial_of_mul_hom T z).map' x = (functorial_of_mul_hom T ghom).map' x,
      { rw [this, sane] },
      convert this; rw End_to_End },
  end }
