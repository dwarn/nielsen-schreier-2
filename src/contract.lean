import free
       quiver
       misc

open_locale classical

open category_theory is_free_groupoid

universe v
variables {G : Type} [groupoid.{v 0} G] [is_free_groupoid G] [inhabited G]
  (T : subquiver (symmy gpd_gens : quiver G))

def path_to_hom : Π {a : G}, (¡T).path (default G) a → ((default G) ⟶ a)
| _ quiver.path.nil := 𝟙 _
| _ (quiver.path.cons p ⟨sum.inl f, _⟩) := (path_to_hom p) ≫ (gpd_emb f)
| _ (quiver.path.cons p ⟨sum.inr f, _⟩) := (path_to_hom p) ≫ inv (gpd_emb f)

variable [is_tree ¡T]

def favourite_hom (a : G) : (default G ⟶ a) :=
path_to_hom T (default _)

def to_End {a b : G} (p : a ⟶ b) : End (default G) :=
favourite_hom T a ≫ p ≫ inv (favourite_hom T b)

lemma favourite_hom_root : favourite_hom T (default G) = 𝟙 _ :=
begin
  change path_to_hom T _ = _,
  have : default ((¡T).path (default G) _) = quiver.path.nil,
  { apply unique.default_eq },
  rw this, refl,
end

lemma End_to_End (p : End (default G)) : to_End T p = p :=
by {rw [to_End, favourite_hom_root], simp }

lemma to_End_eq_id {a b : G} {e : gpd_gens a b} :
  (sum.inl e) ∈ T a b ∨ (sum.inr e) ∈ T b a 
    → to_End T (gpd_emb e) = 𝟙 _ := 
begin
  rw [to_End, ←category.assoc, is_iso.comp_inv_eq, category.id_comp,
    favourite_hom, favourite_hom],
  rintro (h | h),
  { set to_b : (¡T).path (default G) b :=
      quiver.path.cons (default _) ⟨sum.inl e, h⟩,
    have : default _ = to_b := unique.default_eq _,
    rw this, refl },
  { set to_a : (¡T).path (default G) a :=
      quiver.path.cons (default _) ⟨sum.inr e, h⟩,
    have : default _ = to_a := unique.default_eq _,
    simp only [this, path_to_hom, is_iso.inv_hom_id, category.comp_id, category.assoc] },
end

def functorial_of_mul_hom {X} [group X] (f : (End (default G)) →* X) :
  functorial (λ (g : G), single_obj.star X) :=
{ map := λ a b p, f (to_End T p),
  map_id' := begin intro a, convert f.map_one, simp [to_End] end,
  map_comp' := begin
    intros a b c p q,
    change _ = _ * _,
    rw ←f.map_mul,
    apply congr_arg,
    simp only [to_End, is_iso.inv_hom_id_assoc, End.mul_def, category.assoc]
  end }

-- an automorphism group in a free groupoid is freely generated by the
-- complement of a spanning tree.
-- conceptually, this is because 
-- `(End r ⟶ X) ≃ (G ⥤ single_obj X / natural isos taking value 1 on r)`
--             `≃ functors G ⥤ single_obj X mapping spanning tree to 1 `
--             `≃ set functions on complement of spanning tree`.
def contract : is_free_group (End (default G)) :=
{ gp_gens := set.compl (tree_symmy T),
  gp_emb := λ tp, to_End T (gpd_emb tp.val.edge),
  gp_lift := begin
    introsI X _ f,
    let f' : quiver_hom gpd_gens ♯(single_obj X) := 
    { obj := λ _, (),
      edge := λ a b e, if h : (sum.inl e ∈ T a b ∨ sum.inr e ∈ T b a) then 𝟙 _
                       else f ⟨⟨a, b, e⟩, h⟩ },
    rcases gpd_lift f' with ⟨F, hF, uF⟩,
    resetI,
    have map_eq_map' : ∀ {a b : G} (p : a ⟶ b), map f'.obj p = F.map' p := λ _ _ _, rfl,
    have F_path_to_hom : ∀ {a : G} {p : (¡T).path (default G) a},
      map f'.obj (path_to_hom T p) = 𝟙 _,
    { intros a p,
      induction p with b c p e ih,
      { apply functorial.map_id },
      rcases e with ⟨e, eT⟩,
      rcases e with e | e,
      { change map f'.obj (_ ≫ _ ) = _,
        rw [functorial.map_comp, ih, map_eq_map', ←hF],
        change _ ≫ dite _ _ _ = _,
        rw dif_pos (or.inl eT),
        apply category.comp_id },
      { change map f'.obj (_ ≫ inv _) = _,
        rw [functorial.map_comp, ih, functorial.map_inv],
        suffices : map f'.obj (gpd_emb e) = 𝟙 _,
        { simp only [this, is_iso.comp_inv_eq, category.comp_id] },
        rw [map_eq_map', ←hF],
        change dite _ _ _ = _,
        rw dif_pos (or.inr eT) } },
    let ghom : (End (default G)) →* X := functor.map_End (default G) (functor.of f'.obj),
    have sane : functorial_of_mul_hom T ghom = F,
    { rw functorial_ext, intros,
      change map f'.obj ((path_to_hom T _) ≫ _ ≫ inv (path_to_hom T _)) = _,
      rw [functorial.map_comp, functorial.map_comp, functorial.map_inv, 
          F_path_to_hom, F_path_to_hom, map_eq_map'],
      simp only [is_iso.comp_inv_eq, category.id_comp, category.comp_id] },
    refine ⟨ghom, _, _⟩,
    { intro tp,
      change f _ = (functorial_of_mul_hom T ghom).map' _,
      rw [sane, ←hF], change f _ = dite _ _ _,
      rw dif_neg,
      { apply congr_arg, ext; refl },
      exact tp.property },
    { intros z zh,
      have : functorial_of_mul_hom T z = F,
      { apply uF, intros a b e,
        change dite _ _ _ = z (to_End T _),
        by_cases sum.inl e ∈ T a b ∨ sum.inr e ∈ T b a,
        { rw [dif_pos h, to_End_eq_id T h], exact z.map_one.symm },
        { rw [dif_neg h, zh] } },
      ext,
      have : (functorial_of_mul_hom T z).map' x = (functorial_of_mul_hom T ghom).map' x,
      { rw [this, sane] },
      convert this; rw End_to_End },
  end }
