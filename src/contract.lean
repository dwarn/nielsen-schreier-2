import free quiver

open_locale classical

open category_theory

lemma functorial.map_inv {C D} [groupoid C] [groupoid D] {ob : C → D}
  (f : functorial ob) (a b : C) (p : a ⟶ b) :
    f.map (inv p) = inv (f.map p) :=
begin
  suffices : f.map (inv p) = inv (f.map p) ≫ (𝟙 _),
  { simp only [this, category.comp_id]},
  rw [is_iso.eq_inv_comp, ←f.map_comp'],
  simp only [f.map_id', is_iso.hom_inv_id],
end

def functorial.to_functor {C D} [category C] [category D] {ob : C → D}
  (f : functorial ob) : C ⥤ D :=
{ obj := ob,
  map := f.map,
  map_id' := λ a, f.map_id' _,
  map_comp' := λ _ _ _ _ _, f.map_comp' _ _ }

-- we should be able to generalise universe level with a universe-polymorphic single-obj
universe u
variables {G : Type} [groupoid.{u 0} G] {A : subquiver ♯G}
  (T : subquiver ((¡A) ⊕ (¡A)ᵒᵖ)) [inhabited G]

local notation `r` := default G

def path_to_hom : Π {a : G}, (¡T).path r a → (r ⟶ a)
| _ quiver.path.nil := 𝟙 r
| _ (quiver.path.cons p ⟨sum.inl f, _⟩) := (path_to_hom p) ≫ f.val
| _ (quiver.path.cons p ⟨sum.inr f, _⟩) := (path_to_hom p) ≫ inv f.val

variable [(¡T).is_tree]

def favourite_hom (a : G) : (r ⟶ a) :=
path_to_hom T (quiver.is_tree.favourite _)

def to_End {a b : G} (p : a ⟶ b) : End r :=
favourite_hom T a ≫ p ≫ inv (favourite_hom T b)

def generators : set (End r) :=
{ x | ∃ a b (e : A a b), 
  x = to_End T e.val
  ∧ ¬ ( (sum.inl e) ∈ T a b ∨ (sum.inr e) ∈ T b a) }

lemma favourite_hom_root : favourite_hom T r = 𝟙 r :=
begin
  change path_to_hom T _ = _,
  have : quiver.is_tree.favourite r = quiver.path.nil,
  { symmetry, apply quiver.is_tree.is_favourite },
  rw this, refl,
end

lemma End_to_End (p : End r) : to_End T p = p :=
by {rw [to_End, favourite_hom_root], simp }

lemma to_End_eq_id {a b : G} {e : (¡A) a b} :
  (sum.inl e) ∈ T a b ∨ (sum.inr e) ∈ T b a 
    → to_End T e.val = 𝟙 r := 
begin
  rw [to_End, ←category.assoc, is_iso.comp_inv_eq, category.id_comp,
    favourite_hom, favourite_hom],
  rintro (h | h),
  { set to_b : (¡T).path r b :=
      quiver.path.cons (quiver.is_tree.favourite _) ⟨sum.inl e, h⟩,
    have : to_b = _ := quiver.is_tree.is_favourite _,
    rw ←this, refl },
  { set to_a : (¡T).path r a :=
      quiver.path.cons (quiver.is_tree.favourite _) ⟨sum.inr e, h⟩,
    have : to_a = _ := quiver.is_tree.is_favourite _,
    rw [←this, path_to_hom],
    simp only [is_iso.inv_hom_id, category.comp_id, category.assoc], },
end

def functor_of_mul_hom {X : Group} (f : (End r) →* X) :
  @functorial G _ (single_obj X) _ (λ _, ()) :=
{ map := λ a b p, f (to_End T p),
  map_id' := begin intro a, convert f.map_one, simp [to_End] end,
  map_comp' := begin
    intros a b c p q,
    change _ = _ * _,
    rw ←f.map_mul,
    apply congr_arg,
    simp only [to_End, is_iso.inv_hom_id_assoc, End.mul_def, category.assoc]
  end }

-- an automorphism group in a free groupoid is freely generated by the
-- complement of a spanning tree.
-- conceptually, this is because 
-- `(End r ⟶ X) ≃ (G ⥤ single_obj X / natural isos taking value 1 on r)`
--             `≃ functors G ⥤ single_obj X mapping spanning tree to 1 `
--             `≃ set functions on complement of spanning tree`.
theorem contract (hfree : is_free_groupoid G A) : is_free_group (End r) (generators T)
 :=
assume X f,
let ob : G → (single_obj X) := λ _, single_obj.star _ in
let f' : (¡A) →[ob] ♯(single_obj X) := 
  λ a b e, if   h : _ then 𝟙 _
           else f ⟨_, a, b, e, rfl, h⟩ in
let ⟨F, hF, uF⟩ := hfree (Groupoid.of $ single_obj X) ob f' in
have F_path_to_hom : Π {a : G} {p : (¡T).path r a}, F.map (path_to_hom T p) = 𝟙 _ :=
begin
  intros a p,
  induction p with b c p e ih,
  { apply F.map_id' },
  rcases e with ⟨e, eT⟩,
  rcases e with ⟨e, eA⟩ | ⟨e, eA⟩,
  { change F.map (_ ≫ _) = _,
    rw [F.map_comp', ih],
    change (𝟙 _) ≫ (♮F ⊚ sub_hom A) _ = _,
    rw ←hF,
    change (𝟙 _) ≫ dite _ _ _ = _,
    rw dif_pos (or.inl eT),
    simp only [category.comp_id]},
  { change F.map (_ ≫ inv _) = _,
    rw [F.map_comp', ih, F.map_inv],
    suffices : F.map e = 𝟙 _,
    { simp only [this, is_iso.comp_inv_eq, category.comp_id]},
    change (♮F ⊚ sub_hom A) ⟨e, eA⟩ = _,
    rw ←hF,
    change dite _ _ _ = _,
    rw dif_pos (or.inr eT) }
end,
let ghom : (End r) →* X := functor.map_End r F.to_functor in
have sane : functor_of_mul_hom T ghom = F := begin
  ext,
  change F.map (path_to_hom T _ ≫ _ ≫ inv (path_to_hom _ _)) = F.map _,
  rw [F.map_comp', F.map_comp', functorial.map_inv, F_path_to_hom, F_path_to_hom],
  simp only [is_iso.comp_inv_eq, category.id_comp, category.comp_id],
end,
⟨ghom,
begin
  funext, rcases x with ⟨_, a, b, p, ⟨⟩, nn⟩,
  change f _ = (functor_of_mul_hom T ghom).map _,
  rw sane, change f _ = (♮F ⊚ sub_hom A) _,
  rw ←hF, change f _ = dite _ _ _,
  rw dif_neg nn, refl,
end,
begin
  intros z zh, ext,
  have : functor_of_mul_hom T z = F,
  { apply uF, ext,
    change dite _ _ _ = z (to_End T x_3.val),
    by_cases (sum.inl x_3) ∈ T _ _ ∨ (sum.inr x_3) ∈ T _ _,
    { rw [dif_pos h, to_End_eq_id T h],
      change _ = z 1, rw z.map_one, refl },
    { rw [dif_neg h, zh], refl } },
  have : (functor_of_mul_hom T z).map x = (functor_of_mul_hom T ghom).map x,
  { rw [this, sane] },
  convert this; rw End_to_End
end⟩