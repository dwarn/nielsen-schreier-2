import free quiver misc

open_locale classical

open category_theory is_free_groupoid

universe u
variables {G : Type u} [groupoid.{u u} G] [is_free_groupoid G] [inhabited G]
  (T : subquiver (symmy gpd_gens : quiver G))

def path_to_hom : Π {a : G}, (¡T).path (default G) a → ((default G) ⟶ a)
| _ quiver.path.nil := 𝟙 _
| _ (quiver.path.cons p ⟨sum.inl f, _⟩) := (path_to_hom p) ≫ (gpd_emb f)
| _ (quiver.path.cons p ⟨sum.inr f, _⟩) := (path_to_hom p) ≫ inv (gpd_emb f)

variable [is_arbor ¡T]

def favourite_hom (a : G) : (default G ⟶ a) :=
path_to_hom T (default _)

def to_End {a b : G} (p : a ⟶ b) : End (default G) :=
favourite_hom T a ≫ p ≫ inv (favourite_hom T b)

lemma favourite_hom_root : favourite_hom T (default G) = 𝟙 _ :=
begin
  change path_to_hom T _ = _,
  have : default ((¡T).path (default G) _) = quiver.path.nil,
  { apply unique.default_eq },
  rw this, refl,
end

lemma End_to_End (p : End (default G)) : to_End T p = p :=
by {rw [to_End, favourite_hom_root], simp }

lemma to_End_eq_id {a b : G} {e : gpd_gens a b} :
  (sum.inl e) ∈ T a b ∨ (sum.inr e) ∈ T b a 
    → to_End T (gpd_emb e) = 𝟙 _ := 
begin
  rw [to_End, ←category.assoc, is_iso.comp_inv_eq, category.id_comp,
    favourite_hom, favourite_hom],
  rintro (h | h),
  { set to_b : (¡T).path (default G) b :=
      quiver.path.cons (default _) ⟨sum.inl e, h⟩,
    have : default _ = to_b := unique.default_eq _,
    rw this, refl },
  { set to_a : (¡T).path (default G) a :=
      quiver.path.cons (default _) ⟨sum.inr e, h⟩,
    have : default _ = to_a := unique.default_eq _,
    simp only [this, path_to_hom, is_iso.inv_hom_id, category.comp_id, category.assoc] },
end

def functor_of_mul_hom {X} [group X] (f : (End (default G)) →* X) :
  G ⥤ single_obj X :=
{ obj := λ _, (),
  map := λ a b p, f (to_End T p),
  map_id' := begin intro a, convert f.map_one, simp [to_End] end,
  map_comp' := begin
    intros a b c p q,
    change _ = _ * _,
    rw ←f.map_mul,
    apply congr_arg,
    simp only [to_End, is_iso.inv_hom_id_assoc, End.mul_def, category.assoc]
  end }

-- an automorphism group in a free groupoid is freely generated by the
-- complement of a spanning tree.
-- conceptually, this is because 
-- `(End r ⟶ X) ≃ (G ⥤ single_obj X / natural isos taking value 1 on r)`
--             `≃ functors G ⥤ single_obj X mapping spanning tree to 1 `
--             `≃ set functions on complement of spanning tree`.
def contract : is_free_group (End (default G)) :=
{ gp_gens := set.compl (tree_symmy T),
  gp_emb := λ tp, to_End T (gpd_emb tp.val.edge),
  gp_lift := begin
    introsI X _ f,
    let f' : valu gpd_gens X := λ a b e,
      if h : (sum.inl e ∈ T a b ∨ sum.inr e ∈ T b a) then 1
      else f ⟨⟨a, b, e⟩, h⟩,
    rcases gpd_lift @f' with ⟨F, hF, uF⟩,
    have F_path_to_hom : ∀ {a : G} {p : (¡T).path (default G) a},
      F.map (path_to_hom T p) = 1,
    { intros a p,
      induction p with b c p e ih,
      { apply F.map_id },
      rcases e with ⟨e, eT⟩,
      rcases e with e | e,
      { change F.map (_ ≫ _ ) = _,
        rw [functor.map_comp, ih, ←hF],
        change _ ≫ dite _ _ _ = _,
        rw dif_pos (or.inl eT),
        apply mul_one },
      { change F.map (_ ≫ inv _) = _,
        rw [F.map_comp, ih, F.map_inv],
        suffices : F.map (gpd_emb e) = 1,
        { rw [is_iso.comp_inv_eq, this], symmetry, apply mul_one },
        rw ←hF,
        change dite _ _ _ = _,
        rw dif_pos (or.inr eT) } },
    let ghom : (End (default G)) →* X := functor.map_End (default G) F,
    have sane : functor_of_mul_hom T ghom = F,
    { apply functor.hext, 
      { intro, apply unit.ext }, 
      intros, apply heq_of_eq,
      change F.map ((path_to_hom T _) ≫ _ ≫ inv (path_to_hom T _)) =
        (show single_obj.star X ⟶ (), from F.map f_1),
      rw [F.map_comp, F.map_comp, F.map_inv, ←category.assoc,
          is_iso.comp_inv_eq, F_path_to_hom, F_path_to_hom],
      change _ * _ = _ * _,
      rw [mul_one, one_mul],
    },
    refine ⟨ghom, _, _⟩,
    { intro tp,
      change f _ = (functor_of_mul_hom T ghom).map _,
      rw [sane, ←hF], change f _ = dite _ _ _,
      rw dif_neg,
      { apply congr_arg, ext; refl },
      exact tp.property },
    { intros z zh,
      have : functor_of_mul_hom T z = F,
      { apply uF, intros a b e,
        change dite _ _ _ = z (to_End T _),
        split_ifs,
        { rw to_End_eq_id T h, exact z.map_one.symm },
        { apply zh } },
      ext,
      have : (functor_of_mul_hom T z).map x = (functor_of_mul_hom T ghom).map x,
      { rw [this, sane] },
      convert this; rw End_to_End },
  end }
