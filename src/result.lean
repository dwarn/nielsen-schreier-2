import arborescence contract category_theory.category.Groupoid

open category_theory

variables {G : Type} [group G] (A : set G) (hfree : is_free_group G A) (H : subgroup G)
include hfree

def main_theorem : { A' : set H // is_free_group H A' } :=
begin
  refine ⟨_, (is_free_group_mul_equiv _ (End_mul_equiv_subgroup H)).mp
    (contract (geodesic_subgraph _) (elements_is_free_groupoid _ _))⟩,
  { exact (subquiver_equiv G).symm A },
  { apply free_groupoid_directed_connected, 
    apply elements_is_free_groupoid,
    rw ←free_group_iff_free_groupoid,
    exact hfree },
  { apply geodesic_tree },
  { rw ←free_group_iff_free_groupoid,
    exact hfree }
end

-- things left to do:
--   can we make `is_free_group` and `is_free_groupoid` into classes?
--   improve code style
--   show that every generator comes from a unique edge in the complement of the spanning tree
--      (probably using the notion of being a free group on a set function)
--   deduce the index formula ?
--   show that the kernel of the map `⟨x, y⟩ →* ℤ` which sends x to 1 and y to 0 is
--    freely generated by `{ x^n y x^(-n) | n ∈ ℤ }`
--    (can do this by showing proving that the geodesic subgraph is what it is)
--   make it easier to find generating sets more generally?