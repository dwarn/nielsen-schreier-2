import algebra.category.Group category_theory.category.Groupoid category_theory.single_obj category_theory.functor
       category_theory.elements quiver to_mathlib displayed

open category_theory

universes u v

-- The property of being the free group on a subset
def is_free_group (G : Group) (A : set G) : Prop :=
‚àÄ (X : Group) (f : A ‚Üí X),
‚àÉ! (F : G ‚ü∂ X), f = F ‚àò coe

-- The property of being the free groupoid on a subquiver
def is_free_groupoid (G : Groupoid.{v u}) (A : subquiver ‚ôØG.Œ±) : Prop :=
‚àÄ (X : Groupoid.{v u}) (x : G.Œ± ‚Üí X.Œ±) (f : ¬°A ‚Üí[x] ‚ôØX.Œ±),
‚àÉ! (F : functorial x), f = (‚ôÆF ‚äö sub_hom A) -- todo figure out why we need brackets

-- a group is free iff it is a free groupoid
lemma free_group_iff_free_groupoid (G : Group) (A : set G) :
  is_free_group G A ‚Üî is_free_groupoid (Groupoid.of $ single_obj G.Œ±) (Œª _ _, A) :=
begin
  split,
  { intros hfree X,
    change ‚àÄ x : punit ‚Üí X.Œ±, _,
    rw function.surjective.forall (const_unit_surjective X.Œ±),
    intros x f,
    specialize hfree (Group.of $ End x) (Œª a, @f (single_obj.star G) (single_obj.star G) a),
    refine ((functor_equiv x).symm.exists_unique_congr _).mp hfree,
    intro g,
    rw [out_of_unit, out_of_unit],
    refl, },
  { intros hfree X f,
    let x := single_obj.star X.Œ±,
    specialize hfree (Groupoid.of $ single_obj X.Œ±) (Œª _, x)
      (Œª _ _ a, f a),
    refine ((functor_equiv x).symm.exists_unique_congr _).mpr hfree,
    intro g,
    rw [out_of_unit, out_of_unit],
    refl, },
end

section covering_map

variables {G : Groupoid} {F : G.Œ± ‚•§ Type*} {X : Groupoid} (x : F.elements ‚Üí X.Œ±)

def homsets {a b : G.Œ±} (f : a ‚ü∂ b) : Type* :=
Œ† (s : F.obj a) (t : F.obj b) (h : t = F.map f s),
  x ‚ü®a, s‚ü© ‚ü∂ x ‚ü®b, t‚ü©

variable {x}

lemma homset_heq {a b : G.Œ±} {p q : a ‚ü∂ b} {P : homsets x p} {Q : homsets x q} (h : p = q)
  (hs : ‚àÄ (s : F.obj a), P s _ rfl = Q s _ (by rw h)) : P == Q :=
by { cases h, apply heq_of_eq, funext, cases x_3, apply hs }

-- this is a complete triviality, but it seems we need to state it in order to do dependent
-- rewriting
lemma hs_congr {a b : G.Œ±} {p : a ‚ü∂ b} (P : homsets x p) {s s' : F.obj a} {t t' : F.obj b}
  {h : t = F.map p s} (hs : s = s') (ht : t = t') :
    P s t h = eq_to_hom (by rw hs) ‚â´ P s' t' (by rwa [hs, ht] at h) ‚â´ eq_to_hom (by rw ht) :=
by { cases hs, cases ht, simp }

variable (x)
-- we could get a displayed category when G is only a category, and then specialise to groupoids
def todo_name_this : displayed_groupoid G.Œ± :=
{ obj := Œª _, unit, 
  mor := Œª a b f _ _, Œ† (s : F.obj a) (t : F.obj b) (h : t = F.map f s),
                      x ‚ü®a, s‚ü© ‚ü∂ x ‚ü®b, t‚ü©,
  id := Œª a _ s t h, eq_to_hom (by simp [h]),
  comp := Œª a b c f g _ _ _ F G s t h, F s _ rfl ‚â´ G _ t (by simp [h]),
  inv := Œª a b _ _ p P s t h, inv (P t s (by { rw h,
    exact (functor_to_types.map_hom_map_inv_apply F ((groupoid.iso_equiv_hom _ _).symm p) s).symm })), -- how to make simp find the above?
  id_comp := begin
      intros a b _ _ p P,
      apply homset_heq (category.id_comp _),
      intro s,
      rw hs_congr P (functor_to_types.map_id_apply F s) rfl,
      simp,
    end,
  comp_id := begin
      intros a b _ _ p P,
      apply homset_heq (category.comp_id _),
      intro s,
      have : F.map (p ‚â´ ùüô b) s = F.map p s,
      { rw [category.comp_id] },
      rw hs_congr P rfl this,
      simp,
    end,
  assoc := begin
      intros a b c d _ _ _ _ p q r P Q R,
      apply homset_heq (category.assoc _ _ _),
      intro s,
      have : F.map (p ‚â´ q) s = F.map q (F.map p s),
      { apply functor_to_types.map_comp_apply },
      rw [hs_congr Q rfl this, hs_congr R this rfl],
      simp,
    end,
  inv_comp := begin
      intros a b _ _ p P, 
      apply homset_heq (groupoid.inv_comp _),
      intro s,
      change inv _ ‚â´ _ = eq_to_hom _,
      have : F.map (groupoid.inv p ‚â´ p) s = s,
      { rw groupoid.inv_comp, apply functor_to_types.map_id_apply },
      rw hs_congr P rfl this,
      simp,
    end,
  comp_inv := begin
      intros a b _ _ p P, 
      apply homset_heq (groupoid.comp_inv _),
      intro s,
      change _ ‚â´ inv _ = eq_to_hom _,
      have : F.map (p ‚â´ groupoid.inv p) s = s,
      { rw groupoid.comp_inv, apply functor_to_types.map_id_apply },
      rw hs_congr P this rfl,
      simp,
    end }

-- we could define this wrt to arbitrary functors
def subquiver_pullback {C} [category C] (F : C ‚•§ Type*) (A : subquiver ‚ôØC) :
  subquiver ‚ôØF.elements :=
Œª a b, { f | f.val ‚àà A a.fst b.fst }

-- Given an action of a free groupoid, its category of elements
-- is freely generated by the pullback subquiver.
-- This lemma corresponds to the fact that any covering map of a graph is
-- also a graph. In the HoTT formalization of Nielsen-Schreier, it corresponds
-- to the fact that `coequalizers are stable under pullback'
lemma elements_is_free_groupoid {G : Groupoid.{u u}} {F : G.Œ± ‚•§ Type u} (A : subquiver ‚ôØG.Œ±) (h : is_free_groupoid G A) :
  is_free_groupoid (Groupoid.of $ F.elements) (subquiver_pullback F A) :=
begin
  intros X x,
  let Y := total_groupoid G.Œ± (todo_name_this x),
  specialize h Y (Œª x, ‚ü®x, ()‚ü©),
  intro f,
  specialize h _,
  { rintros a b p,
    refine ‚ü®p.val, _‚ü©,
    intros s t h,
    apply f,
    exact ‚ü®‚ü®p.val, h.symm‚ü©, p.property‚ü© },

end

end covering_map
